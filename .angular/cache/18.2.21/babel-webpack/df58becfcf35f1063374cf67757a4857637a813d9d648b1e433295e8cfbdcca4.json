{"ast":null,"code":"import _asyncToGenerator from \"E:/Projects/pokemon-angular-2025/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// src/mutation.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Removable } from \"./removable.js\";\nimport { createRetryer } from \"./retryer.js\";\nvar Mutation = class extends Removable {\n  #client;\n  #observers;\n  #mutationCache;\n  #retryer;\n  constructor(config) {\n    super();\n    this.#client = config.client;\n    this.mutationId = config.mutationId;\n    this.#mutationCache = config.mutationCache;\n    this.#observers = [];\n    this.state = config.state || getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n  setOptions(options) {\n    this.options = options;\n    this.updateGcTime(this.options.gcTime);\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  addObserver(observer) {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer);\n      this.clearGcTimeout();\n      this.#mutationCache.notify({\n        type: \"observerAdded\",\n        mutation: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    this.#observers = this.#observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.#mutationCache.notify({\n      type: \"observerRemoved\",\n      mutation: this,\n      observer\n    });\n  }\n  optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === \"pending\") {\n        this.scheduleGc();\n      } else {\n        this.#mutationCache.remove(this);\n      }\n    }\n  }\n  continue() {\n    return this.#retryer?.continue() ??\n    // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n    this.execute(this.state.variables);\n  }\n  execute(variables) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const onContinue = () => {\n        _this.#dispatch({\n          type: \"continue\"\n        });\n      };\n      const mutationFnContext = {\n        client: _this.#client,\n        meta: _this.options.meta,\n        mutationKey: _this.options.mutationKey\n      };\n      _this.#retryer = createRetryer({\n        fn: () => {\n          if (!_this.options.mutationFn) {\n            return Promise.reject(new Error(\"No mutationFn found\"));\n          }\n          return _this.options.mutationFn(variables, mutationFnContext);\n        },\n        onFail: (failureCount, error) => {\n          _this.#dispatch({\n            type: \"failed\",\n            failureCount,\n            error\n          });\n        },\n        onPause: () => {\n          _this.#dispatch({\n            type: \"pause\"\n          });\n        },\n        onContinue,\n        retry: _this.options.retry ?? 0,\n        retryDelay: _this.options.retryDelay,\n        networkMode: _this.options.networkMode,\n        canRun: () => _this.#mutationCache.canRun(_this)\n      });\n      const restored = _this.state.status === \"pending\";\n      const isPaused = !_this.#retryer.canStart();\n      try {\n        if (restored) {\n          onContinue();\n        } else {\n          _this.#dispatch({\n            type: \"pending\",\n            variables,\n            isPaused\n          });\n          yield _this.#mutationCache.config.onMutate?.(variables, _this, mutationFnContext);\n          const context = yield _this.options.onMutate?.(variables, mutationFnContext);\n          if (context !== _this.state.context) {\n            _this.#dispatch({\n              type: \"pending\",\n              context,\n              variables,\n              isPaused\n            });\n          }\n        }\n        const data = yield _this.#retryer.start();\n        yield _this.#mutationCache.config.onSuccess?.(data, variables, _this.state.context, _this, mutationFnContext);\n        yield _this.options.onSuccess?.(data, variables, _this.state.context, mutationFnContext);\n        yield _this.#mutationCache.config.onSettled?.(data, null, _this.state.variables, _this.state.context, _this, mutationFnContext);\n        yield _this.options.onSettled?.(data, null, variables, _this.state.context, mutationFnContext);\n        _this.#dispatch({\n          type: \"success\",\n          data\n        });\n        return data;\n      } catch (error) {\n        try {\n          yield _this.#mutationCache.config.onError?.(error, variables, _this.state.context, _this, mutationFnContext);\n          yield _this.options.onError?.(error, variables, _this.state.context, mutationFnContext);\n          yield _this.#mutationCache.config.onSettled?.(void 0, error, _this.state.variables, _this.state.context, _this, mutationFnContext);\n          yield _this.options.onSettled?.(void 0, error, variables, _this.state.context, mutationFnContext);\n          throw error;\n        } finally {\n          _this.#dispatch({\n            type: \"error\",\n            error\n          });\n        }\n      } finally {\n        _this.#mutationCache.runNext(_this);\n      }\n    })();\n  }\n  #dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            isPaused: true\n          };\n        case \"continue\":\n          return {\n            ...state,\n            isPaused: false\n          };\n        case \"pending\":\n          return {\n            ...state,\n            context: action.context,\n            data: void 0,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: action.isPaused,\n            status: \"pending\",\n            variables: action.variables,\n            submittedAt: Date.now()\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: \"success\",\n            isPaused: false\n          };\n        case \"error\":\n          return {\n            ...state,\n            data: void 0,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: \"error\"\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.#observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.#mutationCache.notify({\n        mutation: this,\n        type: \"updated\",\n        action\n      });\n    });\n  }\n};\nfunction getDefaultState() {\n  return {\n    context: void 0,\n    data: void 0,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: \"idle\",\n    variables: void 0,\n    submittedAt: 0\n  };\n}\nexport { Mutation, getDefaultState };\n//# sourceMappingURL=mutation.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}