{"ast":null,"code":"import _asyncToGenerator from \"E:/Projects/pokemon-angular-2025/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// src/query.ts\nimport { ensureQueryFn, noop, replaceData, resolveEnabled, resolveStaleTime, skipToken, timeUntilStale } from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { CancelledError, canFetch, createRetryer } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = class extends Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #client;\n  #retryer;\n  #defaultOptions;\n  #abortSignalConsumed;\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.#client = config.client;\n    this.#cache = this.#client.getQueryCache();\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = getDefaultState(this.options);\n    this.state = config.state ?? this.#initialState;\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  get promise() {\n    return this.#retryer?.promise;\n  }\n  setOptions(options) {\n    this.options = {\n      ...this.#defaultOptions,\n      ...options\n    };\n    this.updateGcTime(this.options.gcTime);\n    if (this.state && this.state.data === void 0) {\n      const defaultState = getDefaultState(this.options);\n      if (defaultState.data !== void 0) {\n        this.setData(defaultState.data, {\n          updatedAt: defaultState.dataUpdatedAt,\n          manual: true\n        });\n        this.#initialState = defaultState;\n      }\n    }\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({\n      type: \"setState\",\n      state,\n      setStateOptions\n    });\n  }\n  cancel(options) {\n    const promise = this.#retryer?.promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.observers.some(observer => resolveEnabled(observer.options.enabled, this) !== false);\n  }\n  isDisabled() {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive();\n    }\n    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;\n  }\n  isStatic() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(observer => resolveStaleTime(observer.options.staleTime, this) === \"static\");\n    }\n    return false;\n  }\n  isStale() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(observer => observer.getCurrentResult().isStale);\n    }\n    return this.state.data === void 0 || this.state.isInvalidated;\n  }\n  isStaleByTime(staleTime = 0) {\n    if (this.state.data === void 0) {\n      return true;\n    }\n    if (staleTime === \"static\") {\n      return false;\n    }\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n    observer?.refetch({\n      cancelRefetch: false\n    });\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n    observer?.refetch({\n      cancelRefetch: false\n    });\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({\n        type: \"observerAdded\",\n        query: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter(x => x !== observer);\n      if (!this.observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({\n        type: \"observerRemoved\",\n        query: this,\n        observer\n      });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({\n        type: \"invalidate\"\n      });\n    }\n  }\n  fetch(options, fetchOptions) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.state.fetchStatus !== \"idle\" &&\n      // If the promise in the retyer is already rejected, we have to definitely\n      // re-start the fetch; there is a chance that the query is still in a\n      // pending state when that happens\n      _this.#retryer?.status() !== \"rejected\") {\n        if (_this.state.data !== void 0 && fetchOptions?.cancelRefetch) {\n          _this.cancel({\n            silent: true\n          });\n        } else if (_this.#retryer) {\n          _this.#retryer.continueRetry();\n          return _this.#retryer.promise;\n        }\n      }\n      if (options) {\n        _this.setOptions(options);\n      }\n      if (!_this.options.queryFn) {\n        const observer = _this.observers.find(x => x.options.queryFn);\n        if (observer) {\n          _this.setOptions(observer.options);\n        }\n      }\n      if (process.env.NODE_ENV !== \"production\") {\n        if (!Array.isArray(_this.options.queryKey)) {\n          console.error(`As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`);\n        }\n      }\n      const abortController = new AbortController();\n      const addSignalProperty = object => {\n        Object.defineProperty(object, \"signal\", {\n          enumerable: true,\n          get: () => {\n            _this.#abortSignalConsumed = true;\n            return abortController.signal;\n          }\n        });\n      };\n      const fetchFn = () => {\n        const queryFn = ensureQueryFn(_this.options, fetchOptions);\n        const createQueryFnContext = () => {\n          const queryFnContext2 = {\n            client: _this.#client,\n            queryKey: _this.queryKey,\n            meta: _this.meta\n          };\n          addSignalProperty(queryFnContext2);\n          return queryFnContext2;\n        };\n        const queryFnContext = createQueryFnContext();\n        _this.#abortSignalConsumed = false;\n        if (_this.options.persister) {\n          return _this.options.persister(queryFn, queryFnContext, _this);\n        }\n        return queryFn(queryFnContext);\n      };\n      const createFetchContext = () => {\n        const context2 = {\n          fetchOptions,\n          options: _this.options,\n          queryKey: _this.queryKey,\n          client: _this.#client,\n          state: _this.state,\n          fetchFn\n        };\n        addSignalProperty(context2);\n        return context2;\n      };\n      const context = createFetchContext();\n      _this.options.behavior?.onFetch(context, _this);\n      _this.#revertState = _this.state;\n      if (_this.state.fetchStatus === \"idle\" || _this.state.fetchMeta !== context.fetchOptions?.meta) {\n        _this.#dispatch({\n          type: \"fetch\",\n          meta: context.fetchOptions?.meta\n        });\n      }\n      _this.#retryer = createRetryer({\n        initialPromise: fetchOptions?.initialPromise,\n        fn: context.fetchFn,\n        onCancel: error => {\n          if (error instanceof CancelledError && error.revert) {\n            _this.setState({\n              ..._this.#revertState,\n              fetchStatus: \"idle\"\n            });\n          }\n          abortController.abort();\n        },\n        onFail: (failureCount, error) => {\n          _this.#dispatch({\n            type: \"failed\",\n            failureCount,\n            error\n          });\n        },\n        onPause: () => {\n          _this.#dispatch({\n            type: \"pause\"\n          });\n        },\n        onContinue: () => {\n          _this.#dispatch({\n            type: \"continue\"\n          });\n        },\n        retry: context.options.retry,\n        retryDelay: context.options.retryDelay,\n        networkMode: context.options.networkMode,\n        canRun: () => true\n      });\n      try {\n        const data = yield _this.#retryer.start();\n        if (data === void 0) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(`Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${_this.queryHash}`);\n          }\n          throw new Error(`${_this.queryHash} data is undefined`);\n        }\n        _this.setData(data);\n        _this.#cache.config.onSuccess?.(data, _this);\n        _this.#cache.config.onSettled?.(data, _this.state.error, _this);\n        return data;\n      } catch (error) {\n        if (error instanceof CancelledError) {\n          if (error.silent) {\n            return _this.#retryer.promise;\n          } else if (error.revert) {\n            if (_this.state.data === void 0) {\n              throw error;\n            }\n            return _this.state.data;\n          }\n        }\n        _this.#dispatch({\n          type: \"error\",\n          error\n        });\n        _this.#cache.config.onError?.(error, _this);\n        _this.#cache.config.onSettled?.(_this.state.data, error, _this);\n        throw error;\n      } finally {\n        _this.scheduleGc();\n      }\n    })();\n  }\n  #dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            fetchStatus: \"paused\"\n          };\n        case \"continue\":\n          return {\n            ...state,\n            fetchStatus: \"fetching\"\n          };\n        case \"fetch\":\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null\n          };\n        case \"success\":\n          const newState = {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...(!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n          this.#revertState = action.manual ? newState : void 0;\n          return newState;\n        case \"error\":\n          const error = action.error;\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n        case \"invalidate\":\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case \"setState\":\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({\n        query: this,\n        type: \"updated\",\n        action\n      });\n    });\n  }\n};\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? \"fetching\" : \"paused\",\n    ...(data === void 0 && {\n      error: null,\n      status: \"pending\"\n    })\n  };\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\nexport { Query, fetchState };\n//# sourceMappingURL=query.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}