{"ast":null,"code":"import { assertInInjectionContext, inject, Injector, NgZone, computed, signal, effect, untracked } from \"@angular/core\";\nimport { QueryClient, MutationObserver, noop, notifyManager, shouldThrowError } from \"@tanstack/query-core\";\nimport { signalProxy } from \"./signal-proxy.mjs\";\nimport { PENDING_TASKS } from \"./pending-tasks-compat.mjs\";\nfunction injectMutation(injectMutationFn, options) {\n  !(options == null ? void 0 : options.injector) && assertInInjectionContext(injectMutation);\n  const injector = (options == null ? void 0 : options.injector) ?? inject(Injector);\n  const ngZone = injector.get(NgZone);\n  const pendingTasks = injector.get(PENDING_TASKS);\n  const queryClient = injector.get(QueryClient);\n  const optionsSignal = computed(injectMutationFn);\n  const observerSignal = (() => {\n    let instance = null;\n    return computed(() => {\n      return instance || (instance = new MutationObserver(queryClient, optionsSignal()));\n    });\n  })();\n  const mutateFnSignal = computed(() => {\n    const observer = observerSignal();\n    return (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop);\n    };\n  });\n  const resultFromInitialOptionsSignal = computed(() => {\n    const observer = observerSignal();\n    return observer.getCurrentResult();\n  });\n  const resultFromSubscriberSignal = signal(null);\n  effect(() => {\n    const observer = observerSignal();\n    const observerOptions = optionsSignal();\n    untracked(() => {\n      observer.setOptions(observerOptions);\n    });\n  }, {\n    injector\n  });\n  effect(onCleanup => {\n    const observer = observerSignal();\n    let pendingTaskRef = null;\n    untracked(() => {\n      const unsubscribe = ngZone.runOutsideAngular(() => observer.subscribe(notifyManager.batchCalls(state => {\n        ngZone.run(() => {\n          if (state.isPending && !pendingTaskRef) {\n            pendingTaskRef = pendingTasks.add();\n          }\n          if (!state.isPending && pendingTaskRef) {\n            pendingTaskRef();\n            pendingTaskRef = null;\n          }\n          if (state.isError && shouldThrowError(observer.options.throwOnError, [state.error])) {\n            ngZone.onError.emit(state.error);\n            throw state.error;\n          }\n          resultFromSubscriberSignal.set(state);\n        });\n      })));\n      onCleanup(() => {\n        if (pendingTaskRef) {\n          pendingTaskRef();\n          pendingTaskRef = null;\n        }\n        unsubscribe();\n      });\n    });\n  }, {\n    injector\n  });\n  const resultSignal = computed(() => {\n    const resultFromSubscriber = resultFromSubscriberSignal();\n    const resultFromInitialOptions = resultFromInitialOptionsSignal();\n    const result = resultFromSubscriber ?? resultFromInitialOptions;\n    return {\n      ...result,\n      mutate: mutateFnSignal(),\n      mutateAsync: result.mutate\n    };\n  });\n  return signalProxy(resultSignal);\n}\nexport { injectMutation };","map":{"version":3,"names":["assertInInjectionContext","inject","Injector","NgZone","computed","signal","effect","untracked","QueryClient","MutationObserver","noop","notifyManager","shouldThrowError","signalProxy","PENDING_TASKS","injectMutation","injectMutationFn","options","injector","ngZone","get","pendingTasks","queryClient","optionsSignal","observerSignal","instance","mutateFnSignal","observer","variables","mutateOptions","mutate","catch","resultFromInitialOptionsSignal","getCurrentResult","resultFromSubscriberSignal","observerOptions","setOptions","onCleanup","pendingTaskRef","unsubscribe","runOutsideAngular","subscribe","batchCalls","state","run","isPending","add","isError","throwOnError","error","onError","emit","set","resultSignal","resultFromSubscriber","resultFromInitialOptions","result","mutateAsync"],"sources":["E:/Projects/pokemon-angular-2025/node_modules/@tanstack/angular-query-experimental/inject-mutation.mjs"],"sourcesContent":["import { assertInInjectionContext, inject, Injector, NgZone, computed, signal, effect, untracked } from \"@angular/core\";\nimport { QueryClient, MutationObserver, noop, notifyManager, shouldThrowError } from \"@tanstack/query-core\";\nimport { signalProxy } from \"./signal-proxy.mjs\";\nimport { PENDING_TASKS } from \"./pending-tasks-compat.mjs\";\nfunction injectMutation(injectMutationFn, options) {\n  !(options == null ? void 0 : options.injector) && assertInInjectionContext(injectMutation);\n  const injector = (options == null ? void 0 : options.injector) ?? inject(Injector);\n  const ngZone = injector.get(NgZone);\n  const pendingTasks = injector.get(PENDING_TASKS);\n  const queryClient = injector.get(QueryClient);\n  const optionsSignal = computed(injectMutationFn);\n  const observerSignal = (() => {\n    let instance = null;\n    return computed(() => {\n      return instance || (instance = new MutationObserver(queryClient, optionsSignal()));\n    });\n  })();\n  const mutateFnSignal = computed(() => {\n    const observer = observerSignal();\n    return (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop);\n    };\n  });\n  const resultFromInitialOptionsSignal = computed(() => {\n    const observer = observerSignal();\n    return observer.getCurrentResult();\n  });\n  const resultFromSubscriberSignal = signal(null);\n  effect(\n    () => {\n      const observer = observerSignal();\n      const observerOptions = optionsSignal();\n      untracked(() => {\n        observer.setOptions(observerOptions);\n      });\n    },\n    {\n      injector\n    }\n  );\n  effect(\n    (onCleanup) => {\n      const observer = observerSignal();\n      let pendingTaskRef = null;\n      untracked(() => {\n        const unsubscribe = ngZone.runOutsideAngular(\n          () => observer.subscribe(\n            notifyManager.batchCalls((state) => {\n              ngZone.run(() => {\n                if (state.isPending && !pendingTaskRef) {\n                  pendingTaskRef = pendingTasks.add();\n                }\n                if (!state.isPending && pendingTaskRef) {\n                  pendingTaskRef();\n                  pendingTaskRef = null;\n                }\n                if (state.isError && shouldThrowError(observer.options.throwOnError, [state.error])) {\n                  ngZone.onError.emit(state.error);\n                  throw state.error;\n                }\n                resultFromSubscriberSignal.set(state);\n              });\n            })\n          )\n        );\n        onCleanup(() => {\n          if (pendingTaskRef) {\n            pendingTaskRef();\n            pendingTaskRef = null;\n          }\n          unsubscribe();\n        });\n      });\n    },\n    {\n      injector\n    }\n  );\n  const resultSignal = computed(() => {\n    const resultFromSubscriber = resultFromSubscriberSignal();\n    const resultFromInitialOptions = resultFromInitialOptionsSignal();\n    const result = resultFromSubscriber ?? resultFromInitialOptions;\n    return {\n      ...result,\n      mutate: mutateFnSignal(),\n      mutateAsync: result.mutate\n    };\n  });\n  return signalProxy(resultSignal);\n}\nexport {\n  injectMutation\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}