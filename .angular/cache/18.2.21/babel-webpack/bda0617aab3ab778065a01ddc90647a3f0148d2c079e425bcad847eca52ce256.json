{"ast":null,"code":"import { assertInInjectionContext, inject, Injector, DestroyRef, NgZone, computed, signal } from \"@angular/core\";\nimport { QueryClient, notifyManager, replaceEqualDeep } from \"@tanstack/query-core\";\nfunction getResult(mutationCache, options) {\n  return mutationCache.findAll(options.filters).map(mutation => options.select ? options.select(mutation) : mutation.state);\n}\nfunction injectMutationState(injectMutationStateFn = () => ({}), options) {\n  !(options == null ? void 0 : options.injector) && assertInInjectionContext(injectMutationState);\n  const injector = (options == null ? void 0 : options.injector) ?? inject(Injector);\n  const destroyRef = injector.get(DestroyRef);\n  const ngZone = injector.get(NgZone);\n  const queryClient = injector.get(QueryClient);\n  const mutationCache = queryClient.getMutationCache();\n  const resultFromOptionsSignal = computed(() => {\n    return [getResult(mutationCache, injectMutationStateFn()), performance.now()];\n  });\n  const resultFromSubscriberSignal = signal(null);\n  const effectiveResultSignal = computed(() => {\n    const optionsResult = resultFromOptionsSignal();\n    const subscriberResult = resultFromSubscriberSignal();\n    return subscriberResult && subscriberResult[1] > optionsResult[1] ? subscriberResult[0] : optionsResult[0];\n  });\n  const unsubscribe = ngZone.runOutsideAngular(() => mutationCache.subscribe(notifyManager.batchCalls(() => {\n    const [lastResult] = effectiveResultSignal();\n    const nextResult = replaceEqualDeep(lastResult, getResult(mutationCache, injectMutationStateFn()));\n    if (lastResult !== nextResult) {\n      ngZone.run(() => {\n        resultFromSubscriberSignal.set([nextResult, performance.now()]);\n      });\n    }\n  })));\n  destroyRef.onDestroy(unsubscribe);\n  return effectiveResultSignal;\n}\nexport { injectMutationState };\n//# sourceMappingURL=inject-mutation-state.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}