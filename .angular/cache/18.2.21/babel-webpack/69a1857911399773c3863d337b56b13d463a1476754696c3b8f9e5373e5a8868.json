{"ast":null,"code":"// src/mutationCache.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Mutation } from \"./mutation.js\";\nimport { matchMutation, noop } from \"./utils.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar MutationCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#mutations = /* @__PURE__ */new Set();\n    this.#scopes = /* @__PURE__ */new Map();\n    this.#mutationId = 0;\n  }\n  #mutations;\n  #scopes;\n  #mutationId;\n  build(client, options, state) {\n    const mutation = new Mutation({\n      client,\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    this.#mutations.add(mutation);\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const scopedMutations = this.#scopes.get(scope);\n      if (scopedMutations) {\n        scopedMutations.push(mutation);\n      } else {\n        this.#scopes.set(scope, [mutation]);\n      }\n    }\n    this.notify({\n      type: \"added\",\n      mutation\n    });\n  }\n  remove(mutation) {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation);\n      if (typeof scope === \"string\") {\n        const scopedMutations = this.#scopes.get(scope);\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation);\n            if (index !== -1) {\n              scopedMutations.splice(index, 1);\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope);\n          }\n        }\n      }\n    }\n    this.notify({\n      type: \"removed\",\n      mutation\n    });\n  }\n  canRun(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const mutationsWithSameScope = this.#scopes.get(scope);\n      const firstPendingMutation = mutationsWithSameScope?.find(m => m.state.status === \"pending\");\n      return !firstPendingMutation || firstPendingMutation === mutation;\n    } else {\n      return true;\n    }\n  }\n  runNext(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const foundMutation = this.#scopes.get(scope)?.find(m => m !== mutation && m.state.isPaused);\n      return foundMutation?.continue() ?? Promise.resolve();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.#mutations.forEach(mutation => {\n        this.notify({\n          type: \"removed\",\n          mutation\n        });\n      });\n      this.#mutations.clear();\n      this.#scopes.clear();\n    });\n  }\n  getAll() {\n    return Array.from(this.#mutations);\n  }\n  find(filters) {\n    const defaultedFilters = {\n      exact: true,\n      ...filters\n    };\n    return this.getAll().find(mutation => matchMutation(defaultedFilters, mutation));\n  }\n  findAll(filters = {}) {\n    return this.getAll().filter(mutation => matchMutation(filters, mutation));\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter(x => x.state.isPaused);\n    return notifyManager.batch(() => Promise.all(pausedMutations.map(mutation => mutation.continue().catch(noop))));\n  }\n};\nfunction scopeFor(mutation) {\n  return mutation.options.scope?.id;\n}\nexport { MutationCache };","map":{"version":3,"names":["notifyManager","Mutation","matchMutation","noop","Subscribable","MutationCache","constructor","config","mutations","Set","scopes","Map","mutationId","build","client","options","state","mutation","mutationCache","defaultMutationOptions","add","scope","scopeFor","scopedMutations","get","push","set","notify","type","remove","delete","length","index","indexOf","splice","canRun","mutationsWithSameScope","firstPendingMutation","find","m","status","runNext","foundMutation","isPaused","continue","Promise","resolve","clear","batch","forEach","getAll","Array","from","filters","defaultedFilters","exact","findAll","filter","event","listeners","listener","resumePausedMutations","pausedMutations","x","all","map","catch","id"],"sources":["E:/Projects/pokemon-angular-2025/node_modules/@tanstack/query-core/build/modern/mutationCache.js"],"sourcesContent":["// src/mutationCache.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Mutation } from \"./mutation.js\";\nimport { matchMutation, noop } from \"./utils.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar MutationCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#mutations = /* @__PURE__ */ new Set();\n    this.#scopes = /* @__PURE__ */ new Map();\n    this.#mutationId = 0;\n  }\n  #mutations;\n  #scopes;\n  #mutationId;\n  build(client, options, state) {\n    const mutation = new Mutation({\n      client,\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    this.#mutations.add(mutation);\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const scopedMutations = this.#scopes.get(scope);\n      if (scopedMutations) {\n        scopedMutations.push(mutation);\n      } else {\n        this.#scopes.set(scope, [mutation]);\n      }\n    }\n    this.notify({ type: \"added\", mutation });\n  }\n  remove(mutation) {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation);\n      if (typeof scope === \"string\") {\n        const scopedMutations = this.#scopes.get(scope);\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation);\n            if (index !== -1) {\n              scopedMutations.splice(index, 1);\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope);\n          }\n        }\n      }\n    }\n    this.notify({ type: \"removed\", mutation });\n  }\n  canRun(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const mutationsWithSameScope = this.#scopes.get(scope);\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === \"pending\"\n      );\n      return !firstPendingMutation || firstPendingMutation === mutation;\n    } else {\n      return true;\n    }\n  }\n  runNext(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const foundMutation = this.#scopes.get(scope)?.find((m) => m !== mutation && m.state.isPaused);\n      return foundMutation?.continue() ?? Promise.resolve();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: \"removed\", mutation });\n      });\n      this.#mutations.clear();\n      this.#scopes.clear();\n    });\n  }\n  getAll() {\n    return Array.from(this.#mutations);\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (mutation) => matchMutation(defaultedFilters, mutation)\n    );\n  }\n  findAll(filters = {}) {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation));\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);\n    return notifyManager.batch(\n      () => Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop))\n      )\n    );\n  }\n};\nfunction scopeFor(mutation) {\n  return mutation.options.scope?.id;\n}\nexport {\n  MutationCache\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}