{"ast":null,"code":"import { assertInInjectionContext, inject, Injector, NgZone, computed, signal, effect, untracked } from \"@angular/core\";\nimport { QueryClient, MutationObserver, noop, notifyManager, shouldThrowError } from \"@tanstack/query-core\";\nimport { signalProxy } from \"./signal-proxy.mjs\";\nimport { PENDING_TASKS } from \"./pending-tasks-compat.mjs\";\nfunction injectMutation(injectMutationFn, options) {\n  !(options == null ? void 0 : options.injector) && assertInInjectionContext(injectMutation);\n  const injector = (options == null ? void 0 : options.injector) ?? inject(Injector);\n  const ngZone = injector.get(NgZone);\n  const pendingTasks = injector.get(PENDING_TASKS);\n  const queryClient = injector.get(QueryClient);\n  const optionsSignal = computed(injectMutationFn);\n  const observerSignal = (() => {\n    let instance = null;\n    return computed(() => {\n      return instance || (instance = new MutationObserver(queryClient, optionsSignal()));\n    });\n  })();\n  const mutateFnSignal = computed(() => {\n    const observer = observerSignal();\n    return (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop);\n    };\n  });\n  const resultFromInitialOptionsSignal = computed(() => {\n    const observer = observerSignal();\n    return observer.getCurrentResult();\n  });\n  const resultFromSubscriberSignal = signal(null);\n  effect(() => {\n    const observer = observerSignal();\n    const observerOptions = optionsSignal();\n    untracked(() => {\n      observer.setOptions(observerOptions);\n    });\n  }, {\n    injector\n  });\n  effect(onCleanup => {\n    const observer = observerSignal();\n    let pendingTaskRef = null;\n    untracked(() => {\n      const unsubscribe = ngZone.runOutsideAngular(() => observer.subscribe(notifyManager.batchCalls(state => {\n        ngZone.run(() => {\n          if (state.isPending && !pendingTaskRef) {\n            pendingTaskRef = pendingTasks.add();\n          }\n          if (!state.isPending && pendingTaskRef) {\n            pendingTaskRef();\n            pendingTaskRef = null;\n          }\n          if (state.isError && shouldThrowError(observer.options.throwOnError, [state.error])) {\n            ngZone.onError.emit(state.error);\n            throw state.error;\n          }\n          resultFromSubscriberSignal.set(state);\n        });\n      })));\n      onCleanup(() => {\n        if (pendingTaskRef) {\n          pendingTaskRef();\n          pendingTaskRef = null;\n        }\n        unsubscribe();\n      });\n    });\n  }, {\n    injector\n  });\n  const resultSignal = computed(() => {\n    const resultFromSubscriber = resultFromSubscriberSignal();\n    const resultFromInitialOptions = resultFromInitialOptionsSignal();\n    const result = resultFromSubscriber ?? resultFromInitialOptions;\n    return {\n      ...result,\n      mutate: mutateFnSignal(),\n      mutateAsync: result.mutate\n    };\n  });\n  return signalProxy(resultSignal);\n}\nexport { injectMutation };\n//# sourceMappingURL=inject-mutation.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}