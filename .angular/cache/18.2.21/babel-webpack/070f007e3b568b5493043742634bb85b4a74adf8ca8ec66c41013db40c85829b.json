{"ast":null,"code":"// src/timeoutManager.ts\nvar defaultTimeoutProvider = {\n  // We need the wrapper function syntax below instead of direct references to\n  // global setTimeout etc.\n  //\n  // BAD: `setTimeout: setTimeout`\n  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`\n  //\n  // If we use direct references here, then anything that wants to spy on or\n  // replace the global setTimeout (like tests) won't work since we'll already\n  // have a hard reference to the original implementation at the time when this\n  // file was imported.\n  setTimeout: (callback, delay) => setTimeout(callback, delay),\n  clearTimeout: timeoutId => clearTimeout(timeoutId),\n  setInterval: (callback, delay) => setInterval(callback, delay),\n  clearInterval: intervalId => clearInterval(intervalId)\n};\nvar TimeoutManager = class {\n  // We cannot have TimeoutManager<T> as we must instantiate it with a concrete\n  // type at app boot; and if we leave that type, then any new timer provider\n  // would need to support ReturnType<typeof setTimeout>, which is infeasible.\n  //\n  // We settle for type safety for the TimeoutProvider type, and accept that\n  // this class is unsafe internally to allow for extension.\n  #provider = defaultTimeoutProvider;\n  #providerCalled = false;\n  setTimeoutProvider(provider) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (this.#providerCalled && provider !== this.#provider) {\n        console.error(`[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.`, {\n          previous: this.#provider,\n          provider\n        });\n      }\n    }\n    this.#provider = provider;\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#providerCalled = false;\n    }\n  }\n  setTimeout(callback, delay) {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#providerCalled = true;\n    }\n    return this.#provider.setTimeout(callback, delay);\n  }\n  clearTimeout(timeoutId) {\n    this.#provider.clearTimeout(timeoutId);\n  }\n  setInterval(callback, delay) {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#providerCalled = true;\n    }\n    return this.#provider.setInterval(callback, delay);\n  }\n  clearInterval(intervalId) {\n    this.#provider.clearInterval(intervalId);\n  }\n};\nvar timeoutManager = new TimeoutManager();\nfunction systemSetTimeoutZero(callback) {\n  setTimeout(callback, 0);\n}\nexport { TimeoutManager, defaultTimeoutProvider, systemSetTimeoutZero, timeoutManager };","map":{"version":3,"names":["defaultTimeoutProvider","setTimeout","callback","delay","clearTimeout","timeoutId","setInterval","clearInterval","intervalId","TimeoutManager","provider","providerCalled","setTimeoutProvider","process","env","NODE_ENV","console","error","previous","timeoutManager","systemSetTimeoutZero"],"sources":["E:/Projects/pokemon-angular-2025/node_modules/@tanstack/query-core/build/modern/timeoutManager.js"],"sourcesContent":["// src/timeoutManager.ts\nvar defaultTimeoutProvider = {\n  // We need the wrapper function syntax below instead of direct references to\n  // global setTimeout etc.\n  //\n  // BAD: `setTimeout: setTimeout`\n  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`\n  //\n  // If we use direct references here, then anything that wants to spy on or\n  // replace the global setTimeout (like tests) won't work since we'll already\n  // have a hard reference to the original implementation at the time when this\n  // file was imported.\n  setTimeout: (callback, delay) => setTimeout(callback, delay),\n  clearTimeout: (timeoutId) => clearTimeout(timeoutId),\n  setInterval: (callback, delay) => setInterval(callback, delay),\n  clearInterval: (intervalId) => clearInterval(intervalId)\n};\nvar TimeoutManager = class {\n  // We cannot have TimeoutManager<T> as we must instantiate it with a concrete\n  // type at app boot; and if we leave that type, then any new timer provider\n  // would need to support ReturnType<typeof setTimeout>, which is infeasible.\n  //\n  // We settle for type safety for the TimeoutProvider type, and accept that\n  // this class is unsafe internally to allow for extension.\n  #provider = defaultTimeoutProvider;\n  #providerCalled = false;\n  setTimeoutProvider(provider) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (this.#providerCalled && provider !== this.#provider) {\n        console.error(\n          `[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.`,\n          { previous: this.#provider, provider }\n        );\n      }\n    }\n    this.#provider = provider;\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#providerCalled = false;\n    }\n  }\n  setTimeout(callback, delay) {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#providerCalled = true;\n    }\n    return this.#provider.setTimeout(callback, delay);\n  }\n  clearTimeout(timeoutId) {\n    this.#provider.clearTimeout(timeoutId);\n  }\n  setInterval(callback, delay) {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#providerCalled = true;\n    }\n    return this.#provider.setInterval(callback, delay);\n  }\n  clearInterval(intervalId) {\n    this.#provider.clearInterval(intervalId);\n  }\n};\nvar timeoutManager = new TimeoutManager();\nfunction systemSetTimeoutZero(callback) {\n  setTimeout(callback, 0);\n}\nexport {\n  TimeoutManager,\n  defaultTimeoutProvider,\n  systemSetTimeoutZero,\n  timeoutManager\n};\n"],"mappings":"AAAA;AACA,IAAIA,sBAAsB,GAAG;EAC3B;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAC,UAAU,EAAEA,CAACC,QAAQ,EAAEC,KAAK,KAAKF,UAAU,CAACC,QAAQ,EAAEC,KAAK,CAAC;EAC5DC,YAAY,EAAGC,SAAS,IAAKD,YAAY,CAACC,SAAS,CAAC;EACpDC,WAAW,EAAEA,CAACJ,QAAQ,EAAEC,KAAK,KAAKG,WAAW,CAACJ,QAAQ,EAAEC,KAAK,CAAC;EAC9DI,aAAa,EAAGC,UAAU,IAAKD,aAAa,CAACC,UAAU;AACzD,CAAC;AACD,IAAIC,cAAc,GAAG,MAAM;EACzB;EACA;EACA;EACA;EACA;EACA;EACA,CAACC,QAAQ,GAAGV,sBAAsB;EAClC,CAACW,cAAc,GAAG,KAAK;EACvBC,kBAAkBA,CAACF,QAAQ,EAAE;IAC3B,IAAIG,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC,IAAI,IAAI,CAAC,CAACJ,cAAc,IAAID,QAAQ,KAAK,IAAI,CAAC,CAACA,QAAQ,EAAE;QACvDM,OAAO,CAACC,KAAK,CACX,4GAA4G,EAC5G;UAAEC,QAAQ,EAAE,IAAI,CAAC,CAACR,QAAQ;UAAEA;QAAS,CACvC,CAAC;MACH;IACF;IACA,IAAI,CAAC,CAACA,QAAQ,GAAGA,QAAQ;IACzB,IAAIG,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC,IAAI,CAAC,CAACJ,cAAc,GAAG,KAAK;IAC9B;EACF;EACAV,UAAUA,CAACC,QAAQ,EAAEC,KAAK,EAAE;IAC1B,IAAIU,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC,IAAI,CAAC,CAACJ,cAAc,GAAG,IAAI;IAC7B;IACA,OAAO,IAAI,CAAC,CAACD,QAAQ,CAACT,UAAU,CAACC,QAAQ,EAAEC,KAAK,CAAC;EACnD;EACAC,YAAYA,CAACC,SAAS,EAAE;IACtB,IAAI,CAAC,CAACK,QAAQ,CAACN,YAAY,CAACC,SAAS,CAAC;EACxC;EACAC,WAAWA,CAACJ,QAAQ,EAAEC,KAAK,EAAE;IAC3B,IAAIU,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC,IAAI,CAAC,CAACJ,cAAc,GAAG,IAAI;IAC7B;IACA,OAAO,IAAI,CAAC,CAACD,QAAQ,CAACJ,WAAW,CAACJ,QAAQ,EAAEC,KAAK,CAAC;EACpD;EACAI,aAAaA,CAACC,UAAU,EAAE;IACxB,IAAI,CAAC,CAACE,QAAQ,CAACH,aAAa,CAACC,UAAU,CAAC;EAC1C;AACF,CAAC;AACD,IAAIW,cAAc,GAAG,IAAIV,cAAc,CAAC,CAAC;AACzC,SAASW,oBAAoBA,CAAClB,QAAQ,EAAE;EACtCD,UAAU,CAACC,QAAQ,EAAE,CAAC,CAAC;AACzB;AACA,SACEO,cAAc,EACdT,sBAAsB,EACtBoB,oBAAoB,EACpBD,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}