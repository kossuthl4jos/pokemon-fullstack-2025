{"ast":null,"code":"import _asyncToGenerator from \"E:/Projects/pokemon-angular-2025/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"E:/Projects/pokemon-angular-2025/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\n// src/streamedQuery.ts\nimport { addToEnd } from \"./utils.js\";\nfunction streamedQuery({\n  streamFn,\n  refetchMode = \"reset\",\n  reducer = (items, chunk) => addToEnd(items, chunk),\n  initialValue = []\n}) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (context) {\n      const query = context.client.getQueryCache().find({\n        queryKey: context.queryKey,\n        exact: true\n      });\n      const isRefetch = !!query && query.state.data !== void 0;\n      if (isRefetch && refetchMode === \"reset\") {\n        query.setState({\n          status: \"pending\",\n          data: void 0,\n          error: null,\n          fetchStatus: \"fetching\"\n        });\n      }\n      let result = initialValue;\n      const stream = yield streamFn(context);\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n      var _iteratorError;\n      try {\n        for (var _iterator = _asyncIterator(stream), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const chunk = _step.value;\n          {\n            if (context.signal.aborted) {\n              break;\n            }\n            if (!isRefetch || refetchMode !== \"replace\") {\n              context.client.setQueryData(context.queryKey, prev => reducer(prev === void 0 ? initialValue : prev, chunk));\n            }\n            result = reducer(result, chunk);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      if (isRefetch && refetchMode === \"replace\" && !context.signal.aborted) {\n        context.client.setQueryData(context.queryKey, result);\n      }\n      return context.client.getQueryData(context.queryKey);\n    });\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\nexport { streamedQuery };\n//# sourceMappingURL=streamedQuery.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}