{"ast":null,"code":"// src/hydration.ts\nimport { tryResolveSync } from \"./thenable.js\";\nfunction defaultTransformerFn(data) {\n  return data;\n}\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n    ...(mutation.options.scope && {\n      scope: mutation.options.scope\n    }),\n    ...(mutation.meta && {\n      meta: mutation.meta\n    })\n  };\n}\nfunction dehydrateQuery(query, serializeData, shouldRedactErrors) {\n  return {\n    dehydratedAt: Date.now(),\n    state: {\n      ...query.state,\n      ...(query.state.data !== void 0 && {\n        data: serializeData(query.state.data)\n      })\n    },\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n    ...(query.state.status === \"pending\" && {\n      promise: query.promise?.then(serializeData).catch(error => {\n        if (!shouldRedactErrors(error)) {\n          return Promise.reject(error);\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n          console.error(`A query that was dehydrated as pending ended up rejecting. [${query.queryHash}]: ${error}; The error will be redacted in production builds`);\n        }\n        return Promise.reject(new Error(\"redacted\"));\n      })\n    }),\n    ...(query.meta && {\n      meta: query.meta\n    })\n  };\n}\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === \"success\";\n}\nfunction defaultShouldRedactErrors(_) {\n  return true;\n}\nfunction dehydrate(client, options = {}) {\n  const filterMutation = options.shouldDehydrateMutation ?? client.getDefaultOptions().dehydrate?.shouldDehydrateMutation ?? defaultShouldDehydrateMutation;\n  const mutations = client.getMutationCache().getAll().flatMap(mutation => filterMutation(mutation) ? [dehydrateMutation(mutation)] : []);\n  const filterQuery = options.shouldDehydrateQuery ?? client.getDefaultOptions().dehydrate?.shouldDehydrateQuery ?? defaultShouldDehydrateQuery;\n  const shouldRedactErrors = options.shouldRedactErrors ?? client.getDefaultOptions().dehydrate?.shouldRedactErrors ?? defaultShouldRedactErrors;\n  const serializeData = options.serializeData ?? client.getDefaultOptions().dehydrate?.serializeData ?? defaultTransformerFn;\n  const queries = client.getQueryCache().getAll().flatMap(query => filterQuery(query) ? [dehydrateQuery(query, serializeData, shouldRedactErrors)] : []);\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== \"object\" || dehydratedState === null) {\n    return;\n  }\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache();\n  const deserializeData = options?.defaultOptions?.deserializeData ?? client.getDefaultOptions().hydrate?.deserializeData ?? defaultTransformerFn;\n  const mutations = dehydratedState.mutations || [];\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(({\n    state,\n    ...mutationOptions\n  }) => {\n    mutationCache.build(client, {\n      ...client.getDefaultOptions().hydrate?.mutations,\n      ...options?.defaultOptions?.mutations,\n      ...mutationOptions\n    }, state);\n  });\n  queries.forEach(({\n    queryKey,\n    state,\n    queryHash,\n    meta,\n    promise,\n    dehydratedAt\n  }) => {\n    const syncData = promise ? tryResolveSync(promise) : void 0;\n    const rawData = state.data === void 0 ? syncData?.data : state.data;\n    const data = rawData === void 0 ? rawData : deserializeData(rawData);\n    let query = queryCache.get(queryHash);\n    const existingQueryIsPending = query?.state.status === \"pending\";\n    const existingQueryIsFetching = query?.state.fetchStatus === \"fetching\";\n    if (query) {\n      const hasNewerSyncData = syncData &&\n      // We only need this undefined check to handle older dehydration\n      // payloads that might not have dehydratedAt\n      dehydratedAt !== void 0 && dehydratedAt > query.state.dataUpdatedAt;\n      if (state.dataUpdatedAt > query.state.dataUpdatedAt || hasNewerSyncData) {\n        const {\n          fetchStatus: _ignored,\n          ...serializedState\n        } = state;\n        query.setState({\n          ...serializedState,\n          data\n        });\n      }\n    } else {\n      query = queryCache.build(client, {\n        ...client.getDefaultOptions().hydrate?.queries,\n        ...options?.defaultOptions?.queries,\n        queryKey,\n        queryHash,\n        meta\n      },\n      // Reset fetch status to idle to avoid\n      // query being stuck in fetching state upon hydration\n      {\n        ...state,\n        data,\n        fetchStatus: \"idle\",\n        status: data !== void 0 ? \"success\" : state.status\n      });\n    }\n    if (promise && !existingQueryIsPending && !existingQueryIsFetching && (\n    // Only hydrate if dehydration is newer than any existing data,\n    // this is always true for new queries\n    dehydratedAt === void 0 || dehydratedAt > query.state.dataUpdatedAt)) {\n      void query.fetch(void 0, {\n        // RSC transformed promises are not thenable\n        initialPromise: Promise.resolve(promise).then(deserializeData)\n      });\n    }\n  });\n}\nexport { defaultShouldDehydrateMutation, defaultShouldDehydrateQuery, dehydrate, hydrate };","map":{"version":3,"names":["tryResolveSync","defaultTransformerFn","data","dehydrateMutation","mutation","mutationKey","options","state","scope","meta","dehydrateQuery","query","serializeData","shouldRedactErrors","dehydratedAt","Date","now","queryKey","queryHash","status","promise","then","catch","error","Promise","reject","process","env","NODE_ENV","console","Error","defaultShouldDehydrateMutation","isPaused","defaultShouldDehydrateQuery","defaultShouldRedactErrors","_","dehydrate","client","filterMutation","shouldDehydrateMutation","getDefaultOptions","mutations","getMutationCache","getAll","flatMap","filterQuery","shouldDehydrateQuery","queries","getQueryCache","hydrate","dehydratedState","mutationCache","queryCache","deserializeData","defaultOptions","forEach","mutationOptions","build","syncData","rawData","get","existingQueryIsPending","existingQueryIsFetching","fetchStatus","hasNewerSyncData","dataUpdatedAt","_ignored","serializedState","setState","fetch","initialPromise","resolve"],"sources":["E:/Projects/pokemon-angular-2025/node_modules/@tanstack/query-core/build/modern/hydration.js"],"sourcesContent":["// src/hydration.ts\nimport { tryResolveSync } from \"./thenable.js\";\nfunction defaultTransformerFn(data) {\n  return data;\n}\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n    ...mutation.options.scope && { scope: mutation.options.scope },\n    ...mutation.meta && { meta: mutation.meta }\n  };\n}\nfunction dehydrateQuery(query, serializeData, shouldRedactErrors) {\n  return {\n    dehydratedAt: Date.now(),\n    state: {\n      ...query.state,\n      ...query.state.data !== void 0 && {\n        data: serializeData(query.state.data)\n      }\n    },\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n    ...query.state.status === \"pending\" && {\n      promise: query.promise?.then(serializeData).catch((error) => {\n        if (!shouldRedactErrors(error)) {\n          return Promise.reject(error);\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n          console.error(\n            `A query that was dehydrated as pending ended up rejecting. [${query.queryHash}]: ${error}; The error will be redacted in production builds`\n          );\n        }\n        return Promise.reject(new Error(\"redacted\"));\n      })\n    },\n    ...query.meta && { meta: query.meta }\n  };\n}\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === \"success\";\n}\nfunction defaultShouldRedactErrors(_) {\n  return true;\n}\nfunction dehydrate(client, options = {}) {\n  const filterMutation = options.shouldDehydrateMutation ?? client.getDefaultOptions().dehydrate?.shouldDehydrateMutation ?? defaultShouldDehydrateMutation;\n  const mutations = client.getMutationCache().getAll().flatMap(\n    (mutation) => filterMutation(mutation) ? [dehydrateMutation(mutation)] : []\n  );\n  const filterQuery = options.shouldDehydrateQuery ?? client.getDefaultOptions().dehydrate?.shouldDehydrateQuery ?? defaultShouldDehydrateQuery;\n  const shouldRedactErrors = options.shouldRedactErrors ?? client.getDefaultOptions().dehydrate?.shouldRedactErrors ?? defaultShouldRedactErrors;\n  const serializeData = options.serializeData ?? client.getDefaultOptions().dehydrate?.serializeData ?? defaultTransformerFn;\n  const queries = client.getQueryCache().getAll().flatMap(\n    (query) => filterQuery(query) ? [dehydrateQuery(query, serializeData, shouldRedactErrors)] : []\n  );\n  return { mutations, queries };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== \"object\" || dehydratedState === null) {\n    return;\n  }\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache();\n  const deserializeData = options?.defaultOptions?.deserializeData ?? client.getDefaultOptions().hydrate?.deserializeData ?? defaultTransformerFn;\n  const mutations = dehydratedState.mutations || [];\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(({ state, ...mutationOptions }) => {\n    mutationCache.build(\n      client,\n      {\n        ...client.getDefaultOptions().hydrate?.mutations,\n        ...options?.defaultOptions?.mutations,\n        ...mutationOptions\n      },\n      state\n    );\n  });\n  queries.forEach(\n    ({ queryKey, state, queryHash, meta, promise, dehydratedAt }) => {\n      const syncData = promise ? tryResolveSync(promise) : void 0;\n      const rawData = state.data === void 0 ? syncData?.data : state.data;\n      const data = rawData === void 0 ? rawData : deserializeData(rawData);\n      let query = queryCache.get(queryHash);\n      const existingQueryIsPending = query?.state.status === \"pending\";\n      const existingQueryIsFetching = query?.state.fetchStatus === \"fetching\";\n      if (query) {\n        const hasNewerSyncData = syncData && // We only need this undefined check to handle older dehydration\n        // payloads that might not have dehydratedAt\n        dehydratedAt !== void 0 && dehydratedAt > query.state.dataUpdatedAt;\n        if (state.dataUpdatedAt > query.state.dataUpdatedAt || hasNewerSyncData) {\n          const { fetchStatus: _ignored, ...serializedState } = state;\n          query.setState({\n            ...serializedState,\n            data\n          });\n        }\n      } else {\n        query = queryCache.build(\n          client,\n          {\n            ...client.getDefaultOptions().hydrate?.queries,\n            ...options?.defaultOptions?.queries,\n            queryKey,\n            queryHash,\n            meta\n          },\n          // Reset fetch status to idle to avoid\n          // query being stuck in fetching state upon hydration\n          {\n            ...state,\n            data,\n            fetchStatus: \"idle\",\n            status: data !== void 0 ? \"success\" : state.status\n          }\n        );\n      }\n      if (promise && !existingQueryIsPending && !existingQueryIsFetching && // Only hydrate if dehydration is newer than any existing data,\n      // this is always true for new queries\n      (dehydratedAt === void 0 || dehydratedAt > query.state.dataUpdatedAt)) {\n        void query.fetch(void 0, {\n          // RSC transformed promises are not thenable\n          initialPromise: Promise.resolve(promise).then(deserializeData)\n        });\n      }\n    }\n  );\n}\nexport {\n  defaultShouldDehydrateMutation,\n  defaultShouldDehydrateQuery,\n  dehydrate,\n  hydrate\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}