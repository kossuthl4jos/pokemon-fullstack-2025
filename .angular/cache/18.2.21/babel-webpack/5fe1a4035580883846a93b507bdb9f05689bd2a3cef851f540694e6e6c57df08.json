{"ast":null,"code":"import _asyncToGenerator from \"E:/Projects/pokemon-angular-2025/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// src/query.ts\nimport { ensureQueryFn, noop, replaceData, resolveEnabled, resolveStaleTime, skipToken, timeUntilStale } from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { CancelledError, canFetch, createRetryer } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = class extends Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #client;\n  #retryer;\n  #defaultOptions;\n  #abortSignalConsumed;\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.#client = config.client;\n    this.#cache = this.#client.getQueryCache();\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = getDefaultState(this.options);\n    this.state = config.state ?? this.#initialState;\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  get promise() {\n    return this.#retryer?.promise;\n  }\n  setOptions(options) {\n    this.options = {\n      ...this.#defaultOptions,\n      ...options\n    };\n    this.updateGcTime(this.options.gcTime);\n    if (this.state && this.state.data === void 0) {\n      const defaultState = getDefaultState(this.options);\n      if (defaultState.data !== void 0) {\n        this.setData(defaultState.data, {\n          updatedAt: defaultState.dataUpdatedAt,\n          manual: true\n        });\n        this.#initialState = defaultState;\n      }\n    }\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({\n      type: \"setState\",\n      state,\n      setStateOptions\n    });\n  }\n  cancel(options) {\n    const promise = this.#retryer?.promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.observers.some(observer => resolveEnabled(observer.options.enabled, this) !== false);\n  }\n  isDisabled() {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive();\n    }\n    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;\n  }\n  isStatic() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(observer => resolveStaleTime(observer.options.staleTime, this) === \"static\");\n    }\n    return false;\n  }\n  isStale() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(observer => observer.getCurrentResult().isStale);\n    }\n    return this.state.data === void 0 || this.state.isInvalidated;\n  }\n  isStaleByTime(staleTime = 0) {\n    if (this.state.data === void 0) {\n      return true;\n    }\n    if (staleTime === \"static\") {\n      return false;\n    }\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n    observer?.refetch({\n      cancelRefetch: false\n    });\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n    observer?.refetch({\n      cancelRefetch: false\n    });\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({\n        type: \"observerAdded\",\n        query: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter(x => x !== observer);\n      if (!this.observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({\n        type: \"observerRemoved\",\n        query: this,\n        observer\n      });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({\n        type: \"invalidate\"\n      });\n    }\n  }\n  fetch(options, fetchOptions) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.state.fetchStatus !== \"idle\" &&\n      // If the promise in the retyer is already rejected, we have to definitely\n      // re-start the fetch; there is a chance that the query is still in a\n      // pending state when that happens\n      _this.#retryer?.status() !== \"rejected\") {\n        if (_this.state.data !== void 0 && fetchOptions?.cancelRefetch) {\n          _this.cancel({\n            silent: true\n          });\n        } else if (_this.#retryer) {\n          _this.#retryer.continueRetry();\n          return _this.#retryer.promise;\n        }\n      }\n      if (options) {\n        _this.setOptions(options);\n      }\n      if (!_this.options.queryFn) {\n        const observer = _this.observers.find(x => x.options.queryFn);\n        if (observer) {\n          _this.setOptions(observer.options);\n        }\n      }\n      if (process.env.NODE_ENV !== \"production\") {\n        if (!Array.isArray(_this.options.queryKey)) {\n          console.error(`As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`);\n        }\n      }\n      const abortController = new AbortController();\n      const addSignalProperty = object => {\n        Object.defineProperty(object, \"signal\", {\n          enumerable: true,\n          get: () => {\n            _this.#abortSignalConsumed = true;\n            return abortController.signal;\n          }\n        });\n      };\n      const fetchFn = () => {\n        const queryFn = ensureQueryFn(_this.options, fetchOptions);\n        const createQueryFnContext = () => {\n          const queryFnContext2 = {\n            client: _this.#client,\n            queryKey: _this.queryKey,\n            meta: _this.meta\n          };\n          addSignalProperty(queryFnContext2);\n          return queryFnContext2;\n        };\n        const queryFnContext = createQueryFnContext();\n        _this.#abortSignalConsumed = false;\n        if (_this.options.persister) {\n          return _this.options.persister(queryFn, queryFnContext, _this);\n        }\n        return queryFn(queryFnContext);\n      };\n      const createFetchContext = () => {\n        const context2 = {\n          fetchOptions,\n          options: _this.options,\n          queryKey: _this.queryKey,\n          client: _this.#client,\n          state: _this.state,\n          fetchFn\n        };\n        addSignalProperty(context2);\n        return context2;\n      };\n      const context = createFetchContext();\n      _this.options.behavior?.onFetch(context, _this);\n      _this.#revertState = _this.state;\n      if (_this.state.fetchStatus === \"idle\" || _this.state.fetchMeta !== context.fetchOptions?.meta) {\n        _this.#dispatch({\n          type: \"fetch\",\n          meta: context.fetchOptions?.meta\n        });\n      }\n      _this.#retryer = createRetryer({\n        initialPromise: fetchOptions?.initialPromise,\n        fn: context.fetchFn,\n        onCancel: error => {\n          if (error instanceof CancelledError && error.revert) {\n            _this.setState({\n              ..._this.#revertState,\n              fetchStatus: \"idle\"\n            });\n          }\n          abortController.abort();\n        },\n        onFail: (failureCount, error) => {\n          _this.#dispatch({\n            type: \"failed\",\n            failureCount,\n            error\n          });\n        },\n        onPause: () => {\n          _this.#dispatch({\n            type: \"pause\"\n          });\n        },\n        onContinue: () => {\n          _this.#dispatch({\n            type: \"continue\"\n          });\n        },\n        retry: context.options.retry,\n        retryDelay: context.options.retryDelay,\n        networkMode: context.options.networkMode,\n        canRun: () => true\n      });\n      try {\n        const data = yield _this.#retryer.start();\n        if (data === void 0) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(`Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${_this.queryHash}`);\n          }\n          throw new Error(`${_this.queryHash} data is undefined`);\n        }\n        _this.setData(data);\n        _this.#cache.config.onSuccess?.(data, _this);\n        _this.#cache.config.onSettled?.(data, _this.state.error, _this);\n        return data;\n      } catch (error) {\n        if (error instanceof CancelledError) {\n          if (error.silent) {\n            return _this.#retryer.promise;\n          } else if (error.revert) {\n            if (_this.state.data === void 0) {\n              throw error;\n            }\n            return _this.state.data;\n          }\n        }\n        _this.#dispatch({\n          type: \"error\",\n          error\n        });\n        _this.#cache.config.onError?.(error, _this);\n        _this.#cache.config.onSettled?.(_this.state.data, error, _this);\n        throw error;\n      } finally {\n        _this.scheduleGc();\n      }\n    })();\n  }\n  #dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            fetchStatus: \"paused\"\n          };\n        case \"continue\":\n          return {\n            ...state,\n            fetchStatus: \"fetching\"\n          };\n        case \"fetch\":\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null\n          };\n        case \"success\":\n          const newState = {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...(!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n          this.#revertState = action.manual ? newState : void 0;\n          return newState;\n        case \"error\":\n          const error = action.error;\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n        case \"invalidate\":\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case \"setState\":\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({\n        query: this,\n        type: \"updated\",\n        action\n      });\n    });\n  }\n};\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? \"fetching\" : \"paused\",\n    ...(data === void 0 && {\n      error: null,\n      status: \"pending\"\n    })\n  };\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\nexport { Query, fetchState };","map":{"version":3,"names":["ensureQueryFn","noop","replaceData","resolveEnabled","resolveStaleTime","skipToken","timeUntilStale","notifyManager","CancelledError","canFetch","createRetryer","Removable","Query","initialState","revertState","cache","client","retryer","defaultOptions","abortSignalConsumed","constructor","config","setOptions","options","observers","getQueryCache","queryKey","queryHash","getDefaultState","state","scheduleGc","meta","promise","updateGcTime","gcTime","data","defaultState","setData","updatedAt","dataUpdatedAt","manual","optionalRemove","length","fetchStatus","remove","newData","dispatch","type","setState","setStateOptions","cancel","then","catch","Promise","resolve","destroy","silent","reset","isActive","some","observer","enabled","isDisabled","getObserversCount","queryFn","dataUpdateCount","errorUpdateCount","isStatic","staleTime","isStale","getCurrentResult","isInvalidated","isStaleByTime","onFocus","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","onOnline","shouldFetchOnReconnect","addObserver","includes","push","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","invalidate","fetch","fetchOptions","_this","_asyncToGenerator","status","continueRetry","process","env","NODE_ENV","Array","isArray","console","error","abortController","AbortController","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","fetchFn","createQueryFnContext","queryFnContext2","queryFnContext","persister","createFetchContext","context2","context","behavior","onFetch","fetchMeta","initialPromise","fn","onCancel","abort","onFail","failureCount","onPause","onContinue","retry","retryDelay","networkMode","canRun","start","Error","onSuccess","onSettled","onError","#dispatch","action","reducer","fetchFailureCount","fetchFailureReason","fetchState","newState","Date","now","errorUpdatedAt","batch","forEach","onQueryUpdate","initialData","hasData","initialDataUpdatedAt"],"sources":["E:/Projects/pokemon-angular-2025/node_modules/@tanstack/query-core/build/modern/query.js"],"sourcesContent":["// src/query.ts\nimport {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale\n} from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { CancelledError, canFetch, createRetryer } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = class extends Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #client;\n  #retryer;\n  #defaultOptions;\n  #abortSignalConsumed;\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.#client = config.client;\n    this.#cache = this.#client.getQueryCache();\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = getDefaultState(this.options);\n    this.state = config.state ?? this.#initialState;\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  get promise() {\n    return this.#retryer?.promise;\n  }\n  setOptions(options) {\n    this.options = { ...this.#defaultOptions, ...options };\n    this.updateGcTime(this.options.gcTime);\n    if (this.state && this.state.data === void 0) {\n      const defaultState = getDefaultState(this.options);\n      if (defaultState.data !== void 0) {\n        this.setData(defaultState.data, {\n          updatedAt: defaultState.dataUpdatedAt,\n          manual: true\n        });\n        this.#initialState = defaultState;\n      }\n    }\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({ type: \"setState\", state, setStateOptions });\n  }\n  cancel(options) {\n    const promise = this.#retryer?.promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({ silent: true });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false\n    );\n  }\n  isDisabled() {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive();\n    }\n    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;\n  }\n  isStatic() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => resolveStaleTime(observer.options.staleTime, this) === \"static\"\n      );\n    }\n    return false;\n  }\n  isStale() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale\n      );\n    }\n    return this.state.data === void 0 || this.state.isInvalidated;\n  }\n  isStaleByTime(staleTime = 0) {\n    if (this.state.data === void 0) {\n      return true;\n    }\n    if (staleTime === \"static\") {\n      return false;\n    }\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({ type: \"observerAdded\", query: this, observer });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer);\n      if (!this.observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({ type: \"observerRemoved\", query: this, observer });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: \"invalidate\" });\n    }\n  }\n  async fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== \"idle\" && // If the promise in the retyer is already rejected, we have to definitely\n    // re-start the fetch; there is a chance that the query is still in a\n    // pending state when that happens\n    this.#retryer?.status() !== \"rejected\") {\n      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {\n        this.cancel({ silent: true });\n      } else if (this.#retryer) {\n        this.#retryer.continueRetry();\n        return this.#retryer.promise;\n      }\n    }\n    if (options) {\n      this.setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`\n        );\n      }\n    }\n    const abortController = new AbortController();\n    const addSignalProperty = (object) => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions);\n      const createQueryFnContext = () => {\n        const queryFnContext2 = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: this.meta\n        };\n        addSignalProperty(queryFnContext2);\n        return queryFnContext2;\n      };\n      const queryFnContext = createQueryFnContext();\n      this.#abortSignalConsumed = false;\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this\n        );\n      }\n      return queryFn(queryFnContext);\n    };\n    const createFetchContext = () => {\n      const context2 = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn\n      };\n      addSignalProperty(context2);\n      return context2;\n    };\n    const context = createFetchContext();\n    this.options.behavior?.onFetch(context, this);\n    this.#revertState = this.state;\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({ type: \"fetch\", meta: context.fetchOptions?.meta });\n    }\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise,\n      fn: context.fetchFn,\n      onCancel: (error) => {\n        if (error instanceof CancelledError && error.revert) {\n          this.setState({\n            ...this.#revertState,\n            fetchStatus: \"idle\"\n          });\n        }\n        abortController.abort();\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true\n    });\n    try {\n      const data = await this.#retryer.start();\n      if (data === void 0) {\n        if (process.env.NODE_ENV !== \"production\") {\n          console.error(\n            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`\n          );\n        }\n        throw new Error(`${this.queryHash} data is undefined`);\n      }\n      this.setData(data);\n      this.#cache.config.onSuccess?.(data, this);\n      this.#cache.config.onSettled?.(\n        data,\n        this.state.error,\n        this\n      );\n      return data;\n    } catch (error) {\n      if (error instanceof CancelledError) {\n        if (error.silent) {\n          return this.#retryer.promise;\n        } else if (error.revert) {\n          if (this.state.data === void 0) {\n            throw error;\n          }\n          return this.state.data;\n        }\n      }\n      this.#dispatch({\n        type: \"error\",\n        error\n      });\n      this.#cache.config.onError?.(\n        error,\n        this\n      );\n      this.#cache.config.onSettled?.(\n        this.state.data,\n        error,\n        this\n      );\n      throw error;\n    } finally {\n      this.scheduleGc();\n    }\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            fetchStatus: \"paused\"\n          };\n        case \"continue\":\n          return {\n            ...state,\n            fetchStatus: \"fetching\"\n          };\n        case \"fetch\":\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null\n          };\n        case \"success\":\n          const newState = {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            }\n          };\n          this.#revertState = action.manual ? newState : void 0;\n          return newState;\n        case \"error\":\n          const error = action.error;\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n        case \"invalidate\":\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case \"setState\":\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({ query: this, type: \"updated\", action });\n    });\n  }\n};\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? \"fetching\" : \"paused\",\n    ...data === void 0 && {\n      error: null,\n      status: \"pending\"\n    }\n  };\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\nexport {\n  Query,\n  fetchState\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}